% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grammar_analysis.R
\name{analyze_grammar_for_diversity}
\alias{analyze_grammar_for_diversity}
\title{Grammar Analysis for Diverse Initialization (GADI Phase 1)}
\usage{
analyze_grammar_for_diversity(
  grammar,
  use_semantic_awareness = FALSE,
  semantic_group_fn = NULL
)
}
\arguments{
\item{grammar}{Grammar structure from read_pcfg_grammar()}

\item{use_semantic_awareness}{Boolean indicating whether to use semantic-aware
diversity metrics (requires a semantic grouping function)}

\item{semantic_group_fn}{Optional function that groups semantically equivalent
rules. This function should take two arguments:
\itemize{
\item \code{rules}: A list of production rules for a specific non-terminal
\item \code{non_terminal}: The name of the non-terminal these rules belong to
}
The function should return a list of rule groups, where each group is a list
containing rules that are considered semantically equivalent. For example, if
a non-terminal has 5 rules and rules 1 and 3 are equivalent, while rules 2, 4,
and 5 are each distinct, the function should return a list with 4 elements:
\code{list(list(rule1, rule3), list(rule2), list(rule4), list(rule5))}.
This parameter is required if use_semantic_awareness is TRUE.}
}
\value{
A list containing grammar analysis information:
\itemize{
\item \code{start_symbol}: The grammar's start symbol
\item \code{recursive_nts}: Non-terminals with recursive rules
\item \code{dependencies}: List of dependencies between non-terminals
\item \code{rule_counts}: Number of rules for each non-terminal
\item \code{non_terminal_depth}: Minimum tree depths for each non-terminal
\item \code{rule_diversity_index}: Rule Diversity Index (RDI) values
\item \code{semantic_rule_diversity_index}: Semantic-aware RDI values
\item \code{sorted_by_diversity}: Non-terminals sorted by diversity potential
\item \code{sorted_by_rules}: Non-terminals sorted by rule count
\item \code{high_diversity_paths}: Promising grammar paths for diversity
}
}
\description{
Analyzes a grammar to identify key characteristics that influence diversity
potential, including recursive structures, rule diversity indices, and non-terminal
dependencies. This analysis forms the foundation of the Grammar-Aware Diverse
Initialization (GADI) method.
}
\examples{
# Simple grammar analysis without semantic awareness
grammar <- read_pcfg_grammar(system.file("extdata", "expr.bnf", package = "Rpsge"))
analysis <- analyze_grammar_for_diversity(grammar)

# Grammar analysis with semantic awareness for mathematical expressions
# Create a semantic grouping function for commutative operations
semantic_grouper <- function(rules, non_terminal) {
  # Initialize groups
  groups <- list()

  # Track which rules have been grouped
  grouped <- logical(length(rules))

  # For each rule
  for (i in seq_along(rules)) {
    if (grouped[i]) next

    current_group <- list(rules[[i]])
    grouped[i] <- TRUE

    # Check if this is a binary operation with a commutative operator
    if (length(rules[[i]]$symbols) == 3 &&
        rules[[i]]$symbols[2] \%in\% c("+", "*")) {

      # Look for rules with the same operator but operands swapped
      for (j in seq_along(rules)) {
        if (grouped[j] || i == j) next

        # Check for commutativity pattern
        if (length(rules[[j]]$symbols) == 3 &&
            rules[[i]]$symbols[2] == rules[[j]]$symbols[2] &&
            rules[[i]]$symbols[1] == rules[[j]]$symbols[3] &&
            rules[[i]]$symbols[3] == rules[[j]]$symbols[1] &&
            all(rules[[i]]$types == rules[[j]]$types)) {

          current_group <- c(current_group, list(rules[[j]]))
          grouped[j] <- TRUE
        }
      }
    }

    groups <- c(groups, list(current_group))
  }

  return(groups)
}

# Analyze with semantic awareness
semantic_analysis <- analyze_grammar_for_diversity(
  grammar,
  use_semantic_awareness = TRUE,
  semantic_group_fn = semantic_grouper
)

}
