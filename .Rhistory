# Install R6DS if you haven't already
# install.packages("R6DS")
library(R6DS)
library(R6)
OrderedUniqueSetDLL <- R6::R6Class(
"OrderedUniqueSetDLL",
private = list(
elements_dll = NULL, # Use R6DS Doubly Linked List for ordered elements
lookup_env = new.env(hash = TRUE, parent = emptyenv()) # Environment for O(1) lookups, now storing DLL node indices
),
public = list(
#' Initialize the OrderedUniqueSetDLL
#'
#' @return An OrderedUniqueSetDLL object.
initialize = function() {
private$elements_dll <- RDLL$new() # Initialize RDLL
private$lookup_env <- new.env(hash = TRUE, parent = emptyenv())
},
#' Add an element to the OrderedUniqueSetDLL.
#'
#' If the element is already present, it is not added again (uniqueness).
#' Insertion order is preserved.
#'
#' @param element The element to add.
#' @return TRUE if the element was added (i.e., it was new), FALSE otherwise.
add = function(element) {
key_str <- as.character(element) # Use string representation as key for environment
if (!exists(key_str, envir = private$lookup_env, inherits = FALSE)) {
private$elements_dll$push_back(element) # Append to DLL to maintain order
# Store the *index* of the element in DLL into the lookup environment.
# We'll need to get the index to remove later if needed with remove_at
index_in_dll <- private$elements_dll$size # Index of the last element is current size
assign(key_str, index_in_dll, envir = private$lookup_env) # Store index in environment for lookup
return(TRUE)
}
return(FALSE) # Element already exists
},
#' Check if an element is in the OrderedUniqueSetDLL.
#'
#' O(1) lookup using the environment.
#'
#' @param element The element to check for.
#' @return TRUE if the element is in the set, FALSE otherwise.
has = function(element) {
key_str <- as.character(element)
exists(key_str, envir = private$lookup_env, inherits = FALSE)
},
#' Remove an element from the OrderedUniqueSetDLL.
#'
#' Maintains insertion order of remaining elements.
#' O(1) removal using RDLL's remove_at method (after O(1) lookup to get index).
#'
#' @param element The element to remove.
#' @return TRUE if the element was removed, FALSE if it was not found.
delete = function(element) {
key_str <- as.character(element)
if (exists(key_str, envir = private$lookup_env, inherits = FALSE)) {
index_to_remove <- get(key_str, envir = private$lookup_env) # Get the index from lookup env
private$elements_dll$remove_at(index_to_remove) # Remove from DLL using index, which should be O(1) for DLL
# After removing from DLL, we must update the lookup_env.
# Indices in DLL shift after removal. We need to re-index elements after the removed position.
rm(list = key_str, envir = private$lookup_env) # Remove the entry for the deleted element
# Re-index the lookup_env for elements that were after the removed element
# This is not strictly O(1), but it's necessary to keep the indices in lookup_env consistent
# if we are relying on indices for deletion. However, for just uniqueness check and order iteration,
# we might not need to store index. But to use remove_at(index) effectively based on lookup, we stored indices.
# If RDLL had remove_node(node), we could have stored nodes directly and it could be cleaner for removal.
# Rebuild lookup environment with correct indices if needed for subsequent deletions using indices.
# For now, let's just invalidate the lookup and rebuild it based on current DLL content if needed for index-based delete.
# For a truly O(1) delete based on *element*, we'd ideally want to store *node* and have remove_node.
# For now, with remove_at(index), this index invalidation/rebuild is a complexity.
# Invalidate and rebuild lookup_env. A more efficient approach might be possible by updating indices partially.
private$lookup_env <- new.env(hash = TRUE, parent = emptyenv())
for (i in 1:private$elements_dll$size) {
current_element <- private$elements_dll$elem_at(i)
current_key_str <- as.character(current_element)
assign(current_key_str, i, envir = private$lookup_env)
}
return(TRUE)
}
return(FALSE) # Element not found
},
#' Get all elements in the order they were inserted.
#'
#' @return A list of elements in insertion order.
values = function() {
private$elements_dll$toList()
},
#' Get the number of elements in the OrderedUniqueSetDLL.
#'
#' @return The size of the set.
size = function() {
private$elements_dll$size
},
#' Print the OrderedUniqueSetDLL (for debugging/inspection)
print = function() {
cat("<OrderedUniqueSetDLL>\n")
if (self$size() > 0) {
cat("  Elements (insertion order):\n")
dll_list <- private$elements_dll$toList()
for (elem in dll_list) {
cat("    - ", deparse(elem), "\n") # Deparse for better representation of objects
}
} else {
cat("  (empty)\n")
}
invisible(self) # Make print chainable if desired
}
)
)
# Example Usage:
my_dll_set <- OrderedUniqueSetDLL$new()
# Add elements
my_dll_set$add("apple")
library(R6DS)
library(R6)
OrderedUniqueSetDLL <- R6::R6Class(
"OrderedUniqueSetDLL",
private = list(
elements_dll = NULL, # Use R6DS Doubly Linked List for ordered elements
lookup_env = new.env(hash = TRUE, parent = emptyenv()) # Environment for O(1) lookups, now storing DLL node indices
),
public = list(
#' Initialize the OrderedUniqueSetDLL
#'
#' @return An OrderedUniqueSetDLL object.
initialize = function() {
private$elements_dll <- RDLL$new() # Initialize RDLL
private$lookup_env <- new.env(hash = TRUE, parent = emptyenv())
},
#' Add an element to the OrderedUniqueSetDLL.
#'
#' If the element is already present, it is not added again (uniqueness).
#' Insertion order is preserved.
#'
#' @param element The element to add.
#' @return TRUE if the element was added (i.e., it was new), FALSE otherwise.
add = function(element) {
key_str <- as.character(element) # Use string representation as key for environment
if (!exists(key_str, envir = private$lookup_env, inherits = FALSE)) {
private$elements_dll$push_back(element) # Append to DLL to maintain order
# Store the *index* of the element in DLL into the lookup environment.
# We'll need to get the index to remove later if needed with remove_at
index_in_dll <- private$elements_dll$size() # CORRECTED: Call size() as a method
assign(key_str, index_in_dll, envir = private$lookup_env) # Store index in environment for lookup
return(TRUE)
}
return(FALSE) # Element already exists
},
#' Check if an element is in the OrderedUniqueSetDLL.
#'
#' O(1) lookup using the environment.
#'
#' @param element The element to check for.
#' @return TRUE if the element is in the set, FALSE otherwise.
has = function(element) {
key_str <- as.character(element)
exists(key_str, envir = private$lookup_env, inherits = FALSE)
},
#' Remove an element from the OrderedUniqueSetDLL.
#'
#' Maintains insertion order of remaining elements.
#' O(1) removal using RDLL's remove_at method (after O(1) lookup to get index).
#'
#' @param element The element to remove.
#' @return TRUE if the element was removed, FALSE if it was not found.
delete = function(element) {
key_str <- as.character(element)
if (exists(key_str, envir = private$lookup_env, inherits = FALSE)) {
index_to_remove <- get(key_str, envir = private$lookup_env) # Get the index from lookup env
private$elements_dll$remove_at(index_to_remove) # Remove from DLL using index, should be O(1) for DLL
# After removing from DLL, we must update the lookup_env.
# Indices in DLL shift after removal. We need to re-index elements after the removed position.
rm(list = key_str, envir = private$lookup_env) # Remove the entry for the deleted element
# Re-index the lookup_env.  Still O(n) - see previous detailed explanation.
private$lookup_env <- new.env(hash = TRUE, parent = emptyenv())
for (i in 1:private$elements_dll$size()) { # CORRECTED: Call size() as a method here too
current_element <- private$elements_dll$elem_at(i)
current_key_str <- as.character(current_element)
assign(current_key_str, i, envir = private$lookup_env)
}
return(TRUE)
}
return(FALSE) # Element not found
},
#' Get all elements in the order they were inserted.
#'
#' @return A list of elements in insertion order.
values = function() {
private$elements_dll$toList()
},
#' Get the number of elements in the OrderedUniqueSetDLL.
#'
#' @return The size of the set.
size = function() {
private$elements_dll$size() # CORRECTED: Call size() as a method in public interface too for consistency
},
#' Print the OrderedUniqueSetDLL (for debugging/inspection)
print = function() {
cat("<OrderedUniqueSetDLL>\n")
if (self$size() > 0) { # CORRECTED: Call self$size() as method
cat("  Elements (insertion order):\n")
dll_list <- private$elements_dll$toList()
for (elem in dll_list) {
cat("    - ", deparse(elem), "\n") # Deparse for better representation of objects
}
} else {
cat("  (empty)\n")
}
invisible(self) # Make print chainable if desired
}
)
)
# Example Usage (Corrected code):
my_dll_set <- OrderedUniqueSetDLL$new()
# Add elements
my_dll_set$add("apple")
# R6 Ordered Unique Set Class using R6DS::RDLL (Corrected)
library(R6DS)
library(R6)
OrderedSet <- R6::R6Class(
"OrderedSet",
public = list(
initialize = function(iterable = NULL) {
private$.end <- new.env(parent = emptyenv())
private$.end$key <- NULL
private$.end$prev <- private$.end
private$.end$next <- private$.end
OrderedUniqueSet <- R6::R6Class(
"OrderedUniqueSet",
private = list(
elements = list(), # Use a list to maintain insertion order (like a linked list concept)
lookup_env = new.env(hash = TRUE, parent = emptyenv()) # Environment for O(1) lookups
),
public = list(
#' Initialize the OrderedUniqueSet
#'
#' @return An OrderedUniqueSet object.
initialize = function() {
private$elements <- list()
private$lookup_env <- new.env(hash = TRUE, parent = emptyenv())
},
#' Add an element to the OrderedUniqueSet.
#'
#' If the element is already present, it is not added again (uniqueness).
#' Insertion order is preserved.
#'
#' @param element The element to add.
#' @return TRUE if the element was added (i.e., it was new), FALSE otherwise.
add = function(element) {
key_str <- as.character(element) # Use string representation as key for environment
if (!exists(key_str, envir = private$lookup_env, inherits = FALSE)) {
private$elements <- c(private$elements, list(element)) # Append to list to maintain order
assign(key_str, TRUE, envir = private$lookup_env) # Store key in environment for lookup
return(TRUE)
}
return(FALSE) # Element already exists
},
#' Check if an element is in the OrderedUniqueSet.
#'
#' O(1) lookup using the environment.
#'
#' @param element The element to check for.
#' @return TRUE if the element is in the set, FALSE otherwise.
has = function(element) {
key_str <- as.character(element)
exists(key_str, envir = private$lookup_env, inherits = FALSE)
},
#' Remove an element from the OrderedUniqueSet.
#'
#' Maintains insertion order of remaining elements.
#'
#' @param element The element to remove.
#' @return TRUE if the element was removed, FALSE if it was not found.
delete = function(element) {
key_str <- as.character(element)
if (exists(key_str, envir = private$lookup_env, inherits = FALSE)) {
rm(list = key_str, envir = private$lookup_env) # Remove from lookup environment
# Remove from the ordered list (inefficient O(n) operation in the worst case for lists)
# Find the index of the element (value comparison is needed)
index_to_remove <- -1
for (i in seq_along(private$elements)) {
if (identical(private$elements[[i]], element)) {
index_to_remove <- i
break
}
}
if (index_to_remove != -1) {
if (index_to_remove == 1 && length(private$elements) == 1) {
private$elements <- list() # Empty the list if it was the only element
} else if (index_to_remove == 1) {
private$elements <- private$elements[-1] # Remove first element
} else if (index_to_remove == length(private$elements)) {
private$elements <- private$elements[-length(private$elements)] # Remove last element
} else {
private$elements <- c(private$elements[1:(index_to_remove - 1)], private$elements[(index_to_remove + 1):length(private$elements)]) # Remove from middle
}
}
return(TRUE)
}
return(FALSE) # Element not found
},
#' Get all elements in the order they were inserted.
#'
#' @return A list of elements in insertion order.
values = function() {
private$elements
},
#' Get the number of elements in the OrderedUniqueSet.
#'
#' @return The size of the set.
size = function() {
length(private$elements)
},
#' Print the OrderedUniqueSet (for debugging/inspection)
print = function() {
cat("<OrderedUniqueSet>\n")
if (self$size() > 0) {
cat("  Elements (insertion order):\n")
for (elem in private$elements) {
cat("    - ", deparse(elem), "\n") # Deparse for better representation of objects
}
} else {
cat("  (empty)\n")
}
invisible(self) # Make print chainable if desired
}
)
)
# Example Usage:
my_set <- OrderedUniqueSet$new()
# Add elements
my_set$add("apple")
my_set$add("banana")
my_set$add("cherry")
my_set$add("banana") # Duplicate, won't be added again
my_set$add(123)
my_set$add(TRUE)
my_set$add(list(a = 1, b = 2))
my_set$print()
# Check if elements exist
print(paste("Has 'banana':", my_set$has("banana"))) # TRUE
print(paste("Has 'grape':", my_set$has("grape")))   # FALSE
print(paste("Has 123:", my_set$has(123)))           # TRUE
# Get values in insertion order
print("Values in order:")
print(my_set$values())
# Delete elements
my_set$delete("banana")
print("After deleting 'banana':")
my_set$print()
my_set$delete(123)
print("After deleting 123:")
my_set$print()
my_set$delete("apple")
print("After deleting 'apple':")
my_set$print()
print(paste("Size of set:", my_set$size())) # 4
my_set$add(c(a = 1, b = 2))
my_set$add(matrix(rnorm(10), ncol = 2))
install.packages("digest", dependencies = TRUE)
library(digest)
# R6 Ordered Unique Set Class
OrderedUniqueSet <- R6::R6Class(
"OrderedUniqueSet",
private = list(
elements = list(), # Use a list to maintain insertion order
lookup_env = new.env(hash = TRUE, parent = emptyenv()) # Environment for O(1) lookups
),
public = list(
#' Initialize the OrderedUniqueSet
#'
#' @return An OrderedUniqueSet object.
initialize = function() {
private$elements <- list()
private$lookup_env <- new.env(hash = TRUE, parent = emptyenv())
},
#' Add an element to the OrderedUniqueSet.
#'
#' If the element is already present, it is not added again (uniqueness).
#' Insertion order is preserved.
#'
#' @param element The element to add.
#' @return TRUE if the element was added (i.e., it was new), FALSE otherwise.
add = function(element) {
key_str <- digest::digest(element) # Use digest to create a hash key
if (!exists(key_str, envir = private$lookup_env, inherits = FALSE)) {
private$elements <- c(private$elements, list(element)) # Append to list to maintain order
assign(key_str, TRUE, envir = private$lookup_env) # Store key in environment for lookup
return(TRUE)
}
return(FALSE) # Element already exists
},
#' Check if an element is in the OrderedUniqueSet.
#'
#' O(1) lookup using the environment.
#'
#' @param element The element to check for.
#' @return TRUE if the element is in the set, FALSE otherwise.
has = function(element) {
key_str <- digest::digest(element) # Use digest to create a hash key
exists(key_str, envir = private$lookup_env, inherits = FALSE)
},
#' Remove an element from the OrderedUniqueSet.
#'
#' Maintains insertion order of remaining elements.
#'
#' @param element The element to remove.
#' @return TRUE if the element was removed, FALSE if it was not found.
delete = function(element) {
key_str <- digest::digest(element) # Use digest to create a hash key
if (exists(key_str, envir = private$lookup_env, inherits = FALSE)) {
rm(list = key_str, envir = private$lookup_env) # Remove from lookup environment
# Remove from the ordered list (inefficient O(n) operation in the worst case for lists)
# Find the index of the element (value comparison is needed)
index_to_remove <- -1
for (i in seq_along(private$elements)) {
if (identical(private$elements[[i]], element)) { # Use identical for object comparison
index_to_remove <- i
break
}
}
if (index_to_remove != -1) {
if (index_to_remove == 1 && length(private$elements) == 1) {
private$elements <- list() # Empty the list if it was the only element
} else if (index_to_remove == 1) {
private$elements <- private$elements[-1] # Remove first element
} else if (index_to_remove == length(private$elements)) {
private$elements <- private$elements[-length(private$elements)] # Remove last element
} else {
private$elements <- c(private$elements[1:(index_to_remove - 1)], private$elements[(index_to_remove + 1):length(private$elements)]) # Remove from middle
}
}
return(TRUE)
}
return(FALSE) # Element not found
},
#' Get all elements in the order they were inserted.
#'
#' @return A list of elements in insertion order.
values = function() {
private$elements
},
#' Get the number of elements in the OrderedUniqueSet.
#'
#' @return The size of the set.
size = function() {
length(private$elements)
},
#' Print the OrderedUniqueSet (for debugging/inspection)
print = function() {
cat("<OrderedUniqueSet>\n")
if (self$size() > 0) {
cat("  Elements (insertion order):\n")
for (elem in private$elements) {
cat("    - ", deparse(elem), "\n") # Deparse for better representation of objects
}
} else {
cat("  (empty)\n")
}
invisible(self) # Make print chainable if desired
}
)
)
# Create an OrderedUniqueSet
my_set <- OrderedUniqueSet$new()
# Add various object types
vec1 <- c(1, 2, 3)
vec2 <- c(1, 2, 3) # Identical to vec1
vec3 <- c(3, 2, 1) # Different order
list1 <- list(a = 1, b = "hello")
list2 <- list(a = 1, b = "hello") # Identical to list1
list3 <- list(b = "hello", a = 1) # Different order, but semantically similar (not identical in R's list ordering)
mat1 <- matrix(1:4, nrow = 2)
mat2 <- matrix(1:4, nrow = 2) # Identical to mat1
mat3 <- matrix(4:1, nrow = 2) # Different content
my_set$add(vec1) # Added
my_set$add(vec2) # Not added (duplicate)
my_set$add(vec3) # Added (different content)
my_set$add(list1) # Added
my_set$add(list2) # Not added (duplicate)
my_set$add(list3) # Added (different list structure/order)
my_set$add(mat1) # Added
my_set$add(mat2) # Not added (duplicate)
my_set$add(mat3) # Added (different content)
my_set$print()
cat("Size:", my_set$size(), "\n")
cat("Has vec1:", my_set$has(vec1), "\n")
cat("Has vec2:", my_set$has(vec2), "\n") # Still correctly identifies vec2 as present (though vec1 was added)
cat("Has list1:", my_set$has(list1), "\n")
cat("Has list2:", my_set$has(list2), "\n")
cat("Has mat1:", my_set$has(mat1), "\n")
cat("Has mat2:", my_set$has(mat2), "\n")
my_set$delete(vec2) # Deleting vec2 (which is identical to vec1 in content) - should remove vec1 as it's the instance in the set.
my_set$print() # vec1/vec2 should be removed
cat("Size after delete:", my_set$size(), "\n")
cat("Has vec1 after delete:", my_set$has(vec1), "\n") # Should be FALSE
cat("Has vec2 after delete:", my_set$has(vec2), "\n") # Should be FALSE
my_set$delete(list3)
my_set$print()
cat("Size after delete list3:", my_set$size(), "\n")
cat("Has list3 after delete:", my_set$has(list3), "\n")
my_set$values()
my_set$values()[0]
my_set$values()[1]
my_set$values()[2]
my_set$values()[3]
my_set$values()[4]
my_set$values()[5]
my_set$values()[[4]]
?set
?intersect
